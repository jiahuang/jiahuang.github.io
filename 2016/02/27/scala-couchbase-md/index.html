<!DOCTYPE html><html lang="en-us"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Migrating couchbase entities with Scala | Jia Huang</title><meta name="description"><meta name="generator" content="Jia Huang"><meta name="author" content="Jia Huang"><meta name="keywords" content="jia huang, node.js, javascript, golang, scala, development"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="apple-touch-icon" href="/images/svdb.png"><link rel="icon" type="image/png" href="/images/svdb.png"><meta name="msapplication-TileColor" content="#121315"><meta name="msapplication-TileImage" content="/images/svdb.png"></head><body itemscope itemtype="https://schema.org/WebPage"><header itemscope itemtype="https://schema.org/WPHeader"><img src="/images/profile.png"><h1><a href="/" alt="Jia Huang" title="Jia Huang" itemprop="headline">Jia Huang</a></h1><p itemprop="description"></p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name"><a href="/articles" alt="Writings" title="Writings" itemprop="url">Writings</a></li><li itemprop="name"><a href="/talks" alt="Talks" title="Talks" itemprop="url">Talks</a></li><li itemprop="name"><a href="/projects" alt="Projects" title="Projects" itemprop="url">Projects</a></li><li itemprop="name"><a href="/about" alt="About" title="About" itemprop="url">About</a></li><li><a href="https://github.com/jiahuang"> <img src="/images/github.png" style="height:25px;"></a><a href="https://twitter.com/jia"> <img src="/images/twitter.png" style="height:30px;"></a></li></ul></nav></header><main itemscope itemtype="https://schema.org/Blog"><article class="full"><h1 itemprop="headline">Migrating couchbase entities with Scala</h1><span class="post-meta">Published on<time itemprop="datePublished" datetime="2016-02-28T06:45:31.000Z"> Saturday, February 27th 2016 at 22:45</time><br>Last updated on<time itemprop="dateModified" datetime="2016-02-28T06:45:31.000Z"> Sunday, March 20th 2016 at 21:41</time></span><p>Due to some refactoring, I had to rework some entity models in couchbase. Since the codebase was already in Scala, I decided to write the migration in Scala as well. In reflection, the typesafety of Scala made this task harder than it needed to be.</p>
<p>A simplified example is to change a model that looks like this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OldJobEntity</span></span><br><span class="line">&#123;</span><br><span class="line">  id: <span class="string">"abc123"</span>,</span><br><span class="line">  state: <span class="string">"Complete"</span>,</span><br><span class="line">  links: [&#123;</span><br><span class="line">    s3url: <span class="string">"bucket.s3.amazonaws.com/abc123"</span>,</span><br><span class="line">    signedUrl: <span class="string">"https://bucket.s3.amazonaws.com/abc123?awsSigning"</span>&#125;],</span><br><span class="line">  doctype: <span class="string">"job"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>to something like this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JobEntity</span></span><br><span class="line">&#123;</span><br><span class="line">  id: <span class="string">"abc123"</span>,</span><br><span class="line">  state: <span class="string">"Complete"</span>,</span><br><span class="line">  medias: [&#123;id: <span class="string">"abc123Media"</span>&#125;],</span><br><span class="line">  created: <span class="string">"Sun, 28 Feb 2016 07:10:46 GMT"</span>,</span><br><span class="line">  doctype: <span class="string">"job"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MediaEntity</span></span><br><span class="line"><span class="comment">// with abc123Media being</span></span><br><span class="line">&#123;</span><br><span class="line">  id: <span class="string">"abc123Media"</span>,</span><br><span class="line">  s3url: <span class="string">"bucket.s3.amazonaws.com/abc123"</span>,</span><br><span class="line">  signedUrl: <span class="string">"https://bucket.s3.amazonaws.com/abc123?awsSigning"</span>,</span><br><span class="line">  created: <span class="string">"Sun, 28 Feb 2016 07:10:46 GMT"</span>,</span><br><span class="line">  doctype: <span class="string">"media"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>I had to convert the existing <code>OldJob</code> entities to a new form of a <code>Job</code> entity that now referenced a new <code>Media</code> entity.</p>
<h3 id="Type-checking-when-there-are-2-correct-types"><a href="#Type-checking-when-there-are-2-correct-types" class="headerlink" title="Type checking when there are 2 correct types"></a>Type checking when there are 2 correct types</h3><p>The entities are stored in couchbase as JSON docs, and I used the Spray JSON library for converting back &amp; forth between Scala case classes and JSON. A typical conversion using the <a href="https://github.com/3drobotics/cloud-couchbase-wrapper" target="_blank" rel="external">cloud-couchbase-wrapper</a> looks like this:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> query = couchbase.compoundIndexQueryByRangeToEntity[<span class="type">OldJobEntity</span>]</span><br><span class="line">  (<span class="string">"base"</span>, <span class="string">"doctype"</span>, <span class="comment">// the first two arguments are the design &amp; view names. The "doctype" view in my setup allows me to query for doctypes matching "job"</span></span><br><span class="line">    <span class="type">Some</span>(<span class="type">Seq</span>(<span class="string">"job"</span>, <span class="string">""</span>, <span class="string">""</span>)), <span class="comment">// starting index for the query</span></span><br><span class="line">    <span class="type">Some</span>(<span class="type">Seq</span>(<span class="string">"job"</span>, <span class="string">"ZZZ"</span>, <span class="string">"ZZZ"</span>))) <span class="comment">// ending index for the query</span></span><br></pre></td></tr></table></figure>
<p>But Spray needs to know how to convert a JSON entity to a Scala entity &amp; vice versa. This is done through extending the DefaultProtocol trait:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Protocol</span> <span class="keyword">extends</span> <span class="title">DefaultJsonProtocol</span> </span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> jobFormat = jsonFormat5(<span class="type">JobEntity</span>.apply)</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> mediaFormat = jsonFormat5(<span class="type">MediaEntity</span>.apply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>However I canâ€™t just cast the old <code>job</code> entities to the new <code>job</code> entities because the old entities lack the proper fields (specifically, medias &amp; created). So instead I ended up recreating the old entities as a Scala case class:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">OldJobLinks</span>(<span class="params">s3url: <span class="type">String</span>, signedUrl: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">OldJobEntity</span>(<span class="params">id: <span class="type">String</span>, state: <span class="type">String</span>, links: <span class="type">List</span>[<span class="type">OldJobLinks</span>]</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// this allows us to get new Job Entities and Media Entities from an old job</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">convert</span></span>: (<span class="type">JobEntity</span>, <span class="type">List</span>[<span class="type">MediaEntity</span>]) = &#123;</span><br><span class="line">    <span class="comment">// do some conversion here to return a tuple of things to save</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// extend the old protocol so we can go from json -&gt; old job entity and back</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MigrationProtocol</span> <span class="keyword">extends</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> jobLinksFormat = jsonFormat2(<span class="type">OldJobLinks</span>.apply)</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> oldJobFormat = jsonFormat4(<span class="type">OldJobEntity</span>.apply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Since this migration only touched one type of entity, it wasnâ€™t so annoying. But if I had to add <code>created</code> fields to 10+ types of entities, I would have to add in 10+ old case classes. At that point, I would just skip typecasting and directly use Spray to manipulate JSON.</p>
<h3 id="Preventing-the-migration-script-from-migrating-twice"><a href="#Preventing-the-migration-script-from-migrating-twice" class="headerlink" title="Preventing the migration script from migrating twice"></a>Preventing the migration script from migrating twice</h3><p>If the migration script ever runs twice by accident, I donâ€™t want it messing with already migrated entities. There are two ways of getting around this:</p>
<ol>
<li>Casting all <code>job</code> entities to either <code>OldJob</code> or <code>Job</code> types. If it matches the <code>Job</code>, and not <code>OldJob</code>, donâ€™t migrate.</li>
<li>Add optional fields to the <code>OldJob</code> type so that <code>Job</code> types can also be casted as an <code>OldJob</code>, and check for those optional fields to distinguish between the two.</li>
</ol>
<p>Solution 1 would look something like this:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">couchbase.compoundIndexQueryByRangeToEntity[<span class="type">OldJobEntity</span>]</span><br><span class="line">  (<span class="string">"base"</span>, <span class="string">"doctype"</span>,</span><br><span class="line">    <span class="type">Some</span>(<span class="type">Seq</span>(<span class="string">"job"</span>, <span class="string">""</span>, <span class="string">""</span>)),</span><br><span class="line">    <span class="type">Some</span>(<span class="type">Seq</span>(<span class="string">"job"</span>, <span class="string">"ZZZ"</span>, <span class="string">"ZZZ"</span>))) <span class="comment">// query to get all docs of type "job" and try to cast as old job entity</span></span><br><span class="line">  .map&#123;doc =&gt; doc.entity&#125; <span class="comment">// get the old job from the document stream</span></span><br><span class="line">  .grouped(<span class="type">MaxInt</span>) <span class="comment">// group all the entities together in a list</span></span><br><span class="line">  .runWith(<span class="type">Sink</span>.head) <span class="comment">// get the list of job entities  </span></span><br><span class="line">  .onFailure&#123;</span><br><span class="line">    <span class="keyword">case</span> ex: <span class="type">DeserializationException</span> =&gt; <span class="comment">// try to rerun the same query with casting to JobEntity</span></span><br><span class="line">    <span class="keyword">case</span> ex: <span class="type">Throwable</span> =&gt; <span class="keyword">throw</span> ex</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>And solution 2 looks like:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">OldJobEntity</span>(<span class="params">id: <span class="type">String</span>, state: <span class="type">String</span>, doctype: <span class="type">String</span> // both old and new jobs have these fields</span><br><span class="line">  links: <span class="type">Option</span>[<span class="type">List</span>[<span class="type">OldJobLinks</span>]], // optional because new <span class="type">JobEntities</span> do not have links</span><br><span class="line">  medias: <span class="type">Option</span>[<span class="type">List</span>[<span class="type">MediaEntity</span>]], // optional because old jobs didn't have this</span><br><span class="line">  created: <span class="type">Option</span>[<span class="type">String</span>] // old jobs didn't have this</span><br><span class="line">  </span>)</span>&#123;</span><br><span class="line">    <span class="comment">// convert now returns an option</span></span><br><span class="line">    <span class="comment">// if it has something, we need to convert</span></span><br><span class="line">    <span class="comment">// otherwise if it returns none, the entity has already been migrated</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span></span>: <span class="type">Option</span>[(<span class="type">JobEntity</span>, <span class="type">List</span>[<span class="type">MediaEntity</span>])] = &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.links.nonEmpty) &#123;</span><br><span class="line">        <span class="comment">// this is an old job</span></span><br><span class="line">        <span class="comment">// do some conversion here to return a tuple of things to save</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">None</span> <span class="comment">// this is already a new job, no need to convert</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>I implemented solution 2, but if I had to do it again, I would probably go with solution 1.  </p>
<h3 id="Verification"><a href="#Verification" class="headerlink" title="Verification"></a>Verification</h3><p>Fortunately, the database was still small enough to allow me to run it locally. So to verify the migration, I ended up pulling down the couchbase data from the dev/staging/production servers and running it locally to make sure nothing went wrong.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// ssh into dev servers</span><br><span class="line">ssh ubuntu@server</span><br><span class="line"></span><br><span class="line">// use the couchbase backup util to backup the database</span><br><span class="line">cbbackup http://localhost:8091 ~/dir/to/save/backups -u Administrator -p password</span><br><span class="line"></span><br><span class="line">// zip it up</span><br><span class="line">zip -r ~/dir/to/save/backups/backup.zip ~/dir/to/save/backups/backupFile</span><br><span class="line"></span><br><span class="line">// <span class="built_in">exit</span> out of dev server</span><br><span class="line"></span><br><span class="line">// scp it locally</span><br><span class="line">scp -i ~/.ssh/key.pem ubuntu@server:/home/ubuntu/dir/to/save/backups/backup.zip .</span><br><span class="line"></span><br><span class="line">// restore from a backup</span><br><span class="line">cbrestore ~/dir/to/save/backups/ http://Administrator:password@localhost:8091 --bucket-source=<span class="built_in">source</span>-bucket --bucket-destination=destination-bucket</span><br></pre></td></tr></table></figure>
<p>The datasets that actually got migrated were small enough for me to manually check some edge cases &amp; do some simple counts on number of old entities vs new ones.</p>
<p>In the future when thousands of documents are being migrated, Iâ€™m not quite sure what Iâ€™ll do for verification, but I have a few ideas:</p>
<ol>
<li>load up the entire migrated database as a test set for the unit tests</li>
<li>write some scripts to check for key numbers, such as X number of new <code>media</code> entities being created</li>
<li>push all old entity fields into a stack and pop off the fields as they are found in the new entity fields</li>
</ol>
</article></main></body></html>